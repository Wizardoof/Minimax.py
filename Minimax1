import random
import copy
import time

class Laberinto:
    def __init__(self, filas=5, columnas=5):
        #__init__ inicializador Este m茅todo se llama AUTOMTICAMENTE al crear un objeto
        # Tablero b谩sico 5x5
        self.filas, self.columnas = filas, columnas #self es la identidad de cada fila y columna
        self.tablero = [['.' for _ in range(columnas)] for _ in range(filas)]
        self.gato = (0, 0)           # Gato arriba-izquierda
        self.raton = (filas-1, columnas-1)  # Rat贸n abajo-derecha
        self.turno = 0
        self.max_turnos = 10         # pocos turnos juegos m谩s r谩pidos
        self.actualizar_tablero()
    
    def actualizar_tablero(self):
        #Dibuja el tablero con las posiciones actuales
        # Limpiar tablero
        self.tablero = [['.' for _ in range(self.columnas)] for _ in range(self.filas)]
        # Colocar jugadores
        self.tablero[self.gato[0]][self.gato[1]] = ''
        self.tablero[self.raton[0]][self.raton[1]] = ''
    
    def movimiento_valido(self, pos, jugador):
        #Verifica si un movimiento es permitido
        #pos=posicion, col=columna
        fila, col = pos
        # 1. No salir del tablero
        if not (0 <= fila < self.filas and 0 <= col < self.columnas):
            return False
        # 2. Gato puede atrapar rat贸n
        if jugador == '' and pos == self.raton:
            return True
        # 3. Rat贸n no puede moverse al gato
        if jugador == '' and pos == self.gato:
            return False
        return True
    
    def movimientos_posibles(self, jugador):
        #Lista de movimientos v谩lidos (4 direcciones)
        pos_actual = self.gato if jugador == '' else self.raton
        movimientos = []
        # Solo 4 direcciones para simplificar
        direcciones = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Arriba, abajo, izquierda, derecha
        
        for d in direcciones:
            nueva_pos = (pos_actual[0] + d[0], pos_actual[1] + d[1])
            if self.movimiento_valido(nueva_pos, jugador):
                movimientos.append(nueva_pos)
                
        return movimientos
    
    def mover(self, jugador, nueva_pos):
        """Mueve al jugador y verifica si alguien gana"""
        if jugador == '':
            self.gato = nueva_pos
            if self.gato == self.raton:  # Gato atrapa rat贸n
                return 'GATO_GANA'
        else:
            self.raton = nueva_pos
            self.turno += 1
            if self.turno >= self.max_turnos:  # Rat贸n sobrevive
                return 'RATON_ESCAPA'
        
        self.actualizar_tablero()
        return 'CONTINUA'
    
    def evaluar_estado(self):
        """Funci贸n simple: distancia entre gato y rat贸n"""
        return abs(self.gato[0] - self.raton[0]) + abs(self.gato[1] - self.raton[1])

class Juego:
    def __init__(self, laberinto):
        self.laberinto = laberinto
        self.profundidad = 2  # Solo 2 niveles de profundidad para ser r谩pido
    
    def minimax(self, estado, profundidad, es_maximizador):
        """Algoritmo Minimax"""
        # Casos base: 驴termin贸 el juego?
        if estado.gato == estado.raton:
            return -100  # Malo para rat贸n
        if estado.turno >= estado.max_turnos:
            return 100   # Bueno para rat贸n
        
        if profundidad == 0:
            return estado.evaluar_estado()
        
        if es_maximizador:  # Rat贸n (busca max)
            mejor_valor = -float('inf')
            for movimiento in estado.movimientos_posibles(''):
                nuevo_estado = copy.deepcopy(estado)
                nuevo_estado.mover('', movimiento)
                valor = self.minimax(nuevo_estado, profundidad-1, False)
                mejor_valor = max(mejor_valor, valor)
            return mejor_valor
            
        else:  # Gato (busca mini)
            mejor_valor = float('inf')
            for movimiento in estado.movimientos_posibles(''):
                nuevo_estado = copy.deepcopy(estado)
                nuevo_estado.mover('', movimiento)
                valor = self.minimax(nuevo_estado, profundidad-1, True)
                mejor_valor = min(mejor_valor, valor)
            return mejor_valor
    
    def mejor_movimiento(self, jugador):
        """Encuentra el mejor movimiento para el jugador"""
        movimientos = self.laberinto.movimientos_posibles(jugador)
        if not movimientos:
            return self.laberinto.gato if jugador == '' else self.laberinto.raton
        
        mejor_mov = None
        mejor_valor = -float('inf') if jugador == '' else float('inf')
        
        for movimiento in movimientos:
            nuevo_estado = copy.deepcopy(self.laberinto)
            nuevo_estado.mover(jugador, movimiento)
            
            # Rat贸n maximiza, Gato minimiza
            if jugador == '':
                valor = self.minimax(nuevo_estado, self.profundidad-1, False)
                if valor > mejor_valor:
                    mejor_valor = valor
                    mejor_mov = movimiento
            else:
                valor = self.minimax(nuevo_estado, self.profundidad-1, True)
                if valor < mejor_valor:
                    mejor_valor = valor
                    mejor_mov = movimiento
        
        return mejor_mov if mejor_mov is not None else movimientos[0]
    
    def jugar_turno_ia_vs_ia(self):
        #Un turno completo: rat贸n y luego gato (ambos IA)
        # Rat贸n se mueve
        mov_raton = self.mejor_movimiento('')
        resultado = self.laberinto.mover('', mov_raton)
        if resultado != 'CONTINUA':
            return resultado
        
        # Gato se mueve
        mov_gato = self.mejor_movimiento('')
        return self.laberinto.mover('', mov_gato)

def mostrar_tablero_simple(laberinto):
    #Muestra el tablero de forma simple
    print(f"\nTurno: {laberinto.turno}/{laberinto.max_turnos}")
    for fila in laberinto.tablero:
        print(' '.join(fila))
    print(f"Distancia: {laberinto.evaluar_estado()}")

def obtener_movimiento_jugador(laberinto, jugador):
    #Pide movimiento al jugador humano
    print(f"\nTurno del {'Gato' if jugador == '' else 'Rat贸n'}")
    print("W=Arriba, A=Izquierda, S=Abajo, D=Derecha")
    
    while True:
        tecla = input("Movimiento (W/A/S/D): ").upper()
        movimientos = {'W': (-1, 0), 'A': (0, -1), 'S': (1, 0), 'D': (0, 1)}
        
        if tecla in movimientos:
            pos_actual = laberinto.gato if jugador == '' else laberinto.raton
            movimiento = movimientos[tecla]
            nueva_pos = (pos_actual[0] + movimiento[0], pos_actual[1] + movimiento[1])
            
            if laberinto.movimiento_valido(nueva_pos, jugador):
                return nueva_pos
            else:
                print("Movimiento inv谩lido. Intente otra direcci贸n.")
        else:
            print("Tecla no v谩lida. Use W, A, S o D.")

def simulacion_automatica():
    #Modo: IA vs IA (simulaci贸n autom谩tica)
    lab = Laberinto(5, 5)
    juego = Juego(lab)
    
    print("=== IA vs IA ===")
    while True:
        mostrar_tablero_simple(lab)
        time.sleep(1)
        
        resultado = juego.jugar_turno_ia_vs_ia()
        if resultado != 'CONTINUA':
            mostrar_tablero_simple(lab)
            print("隆Gato gana!" if resultado == 'GATO_GANA' else "隆Rat贸n escapa!")
            break

def jugar_como_raton():
    #Modo: Jugador como rat贸n vs IA gato
    lab = Laberinto(5, 5)
    juego = Juego(lab)
    
    print("=== T煤 como Rat贸n vs IA Gato ===")
    while True:
        mostrar_tablero_simple(lab)
        
        # Jugador (rat贸n)
        mov_raton = obtener_movimiento_jugador(lab, '')
        resultado = lab.mover('', mov_raton)
        if resultado != 'CONTINUA':
            mostrar_tablero_simple(lab)
            print("隆Ganaste!" if resultado == 'RATON_ESCAPA' else "隆Perdiste!")
            break
        
        # IA (gato)
        mov_gato = juego.mejor_movimiento('')
        resultado = lab.mover('', mov_gato)
        if resultado != 'CONTINUA':
            mostrar_tablero_simple(lab)
            print("隆Perdiste! El gato te atrap贸")
            break

def jugar_como_gato():
    #Modo: Jugador como gato vs IA rat贸n
    lab = Laberinto(5, 5)
    juego = Juego(lab)
    
    print("=== T煤 como Gato vs IA Rat贸n ===")
    while True:
        mostrar_tablero_simple(lab)
        
        # IA (rat贸n)
        mov_raton = juego.mejor_movimiento('')
        resultado = lab.mover('', mov_raton)
        if resultado != 'CONTINUA':
            mostrar_tablero_simple(lab)
            print("隆Perdiste! El rat贸n escap贸")
            break
        
        # Jugador (gato)
        mov_gato = obtener_movimiento_jugador(lab, '')
        resultado = lab.mover('', mov_gato)
        if resultado != 'CONTINUA':
            mostrar_tablero_simple(lab)
            print("隆Ganaste! Atrapaste al rat贸n")
            break

def menu_principal():
    #Men煤 para elegir modo de juego
    while True:
        print("\n=== LABERINTO GATO Y RATN ===")
        print("1. Ver IA vs IA")
        print("2. Jugar como Rat贸n")
        print("3. Jugar como Gato")
        print("4. Salir")
        
        opcion = input("Elige (1-4): ")
        
        if opcion == '1':
            simulacion_automatica()
        elif opcion == '2':
            jugar_como_raton()
        elif opcion == '3':
            jugar_como_gato()
        elif opcion == '4':
            print("隆Gracias por jugar!")
            break
        else:
            print("Opci贸n no v谩lida vuelva a intentar")

# Ejecutar el juego
if __name__ == "__main__":
    menu_principal()
